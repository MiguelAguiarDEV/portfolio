---
import type { Pola } from "../../lib/colors";
import { palette } from "../../lib/colors";

export interface Props {
    color?: Pola;
    target?: string;
    title?: string;
}
const { color = "blue", target = "", title = "" } = Astro.props;
---

<color-dot
    data-color={color}
    data-target={target}
    title={title || color}
    aria-label={title || color}
    class="shadow-2xl"
    style={`--dot-color:${palette[color]}; --dot-ring:${palette[color]}66`}
>
    <button
        class="w-3.5 h-3.5 rounded-full shadow-2xl hover:scale-125 transition-transform"
        style={`background:${palette[color]}`}
        type="button"></button>
</color-dot>
<script>
    let txId = 0; // token global
    /**
     * @typedef {Object} RunningState
     * @property {number} id
     * @property {HTMLElement} next
     * @property {HTMLElement|null} curr
     * @property {HTMLElement|null} wipe
     * @property {(ev: AnimationEvent) => void} onEnd
     * @property {HTMLElement[]} toHide
     * @property {string} prevBg
     */
    /** @type {RunningState | null} */
    let running = null; // transición en curso

    /** @type {(s?: string) => string} */
    const norm = (s) => (s?.startsWith("#") ? s : s ? "#" + s : "");

    function cleanupStale() {
        document
            .querySelectorAll(".panel.reveal")
            .forEach((p) => p.classList.remove("reveal"));
    }

    function cancelRunning() {
        if (!running) return;
        const { next, curr, wipe, onEnd, toHide, prevBg } =
            /** @type {RunningState} */ (running);

        // cancela listener y anima instantáneamente a estado consistente
        if (wipe && onEnd) wipe.removeEventListener("animationend", onEnd);

        // rollback del panel destino
        next.classList.remove("reveal", "is-active");
        next.style.zIndex = "0";
        next.style.background = prevBg || "";
        toHide.forEach((el) => (el.style.visibility = ""));

        // el actual vuelve a ser el visible
        if (curr) {
            curr.classList.add("is-active");
            curr.style.zIndex = "1";
        }

        running = null;
    }

    class ColorDotEl extends HTMLElement {
        connectedCallback() {
            const btn = this.querySelector("button");
            if (!btn) return;

            btn.addEventListener("click", () => {
                const sel = norm(this.dataset.target);
                if (!sel) return;

                cleanupStale();
                cancelRunning(); // corta animación previa si existía

                const next = /** @type {HTMLElement | null} */ (
                    document.querySelector(sel)
                );
                const curr = /** @type {HTMLElement | null} */ (
                    document.querySelector(".panel.is-active")
                );
                if (!next || next === curr) return;

                const wipe = /** @type {HTMLElement | null} */ (
                    next.querySelector(".wipe")
                );
                const nextColor = getComputedStyle(next).backgroundColor;

                // prepara destino visible pero con contenido oculto
                const toHide = /** @type {HTMLElement[]} */ (
                    Array.from(next.children).filter(
                        /** @returns {boolean} */
                        (el) =>
                            !/** @type {HTMLElement} */ (el).classList.contains(
                                "wipe",
                            ),
                    )
                );
                const prevBg = next.style.background;
                toHide.forEach((el) => (el.style.visibility = "hidden"));
                next.style.background = "transparent";

                if (curr) curr.style.zIndex = "0";
                next.style.zIndex = "2";
                next.classList.add("is-active");

                const id = ++txId;

                const onEnd = () => {
                    if (!running || running.id !== id) return; // ignorar eventos viejos

                    // finaliza
                    next.style.zIndex = "1";
                    next.classList.remove("reveal");
                    if (curr) curr.classList.remove("is-active");

                    next.style.background = prevBg || nextColor;
                    toHide.forEach((el) => (el.style.visibility = ""));
                    // actualizar dots activos
                    document
                        .querySelectorAll('color-dot[data-active="true"]')
                        .forEach((el) => el.removeAttribute("data-active"));
                    const activeDot = document.querySelector(
                        `color-dot[data-target="#${next.id}"]`,
                    );
                    if (activeDot)
                        activeDot.setAttribute("data-active", "true");
                    running = null;
                };

                if (wipe) {
                    // reinicia y dispara el wipe sin delay
                    wipe.style.animation = "none";
                    wipe.style.setProperty("--wipe-color", nextColor);

                    requestAnimationFrame(() => {
                        // si otro clic se adelantó, aborta
                        if (running && running.id !== id) return;
                        next.classList.add("reveal");
                        wipe.style.animation = ""; // aplica @keyframes
                        wipe.addEventListener("animationend", onEnd, {
                            once: true,
                        });
                    });

                    running = { id, next, curr, wipe, onEnd, toHide, prevBg };
                } else {
                    // sin overlay: cambio inmediato
                    next.style.zIndex = "1";
                    if (curr) curr.classList.remove("is-active");
                    next.style.background = prevBg || nextColor;
                    toHide.forEach((el) => (el.style.visibility = ""));
                    document
                        .querySelectorAll('color-dot[data-active="true"]')
                        .forEach((el) => el.removeAttribute("data-active"));
                    const activeDot = document.querySelector(
                        `color-dot[data-target="#${next.id}"]`,
                    );
                    if (activeDot)
                        activeDot.setAttribute("data-active", "true");
                    running = null;
                }
            });
        }
    }

    if (!customElements.get("color-dot")) {
        customElements.define("color-dot", ColorDotEl);
        // inicial: marcar según panel activo
        requestAnimationFrame(() => {
            const activePanel = document.querySelector(".panel.is-active");
            if (activePanel instanceof HTMLElement) {
                const dot = document.querySelector(
                    `color-dot[data-target=\"#${activePanel.id}\"]`,
                );
                if (dot) dot.setAttribute("data-active", "true");
            } else {
                const first = document.querySelector("color-dot[data-target]");
                if (first) first.setAttribute("data-active", "true");
            }
        });
    }
</script>
