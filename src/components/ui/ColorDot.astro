---
import type { Pola } from "../../lib/colors";
import { palette } from "../../lib/colors";

export interface Props {
    color?: Pola;
    target?: string; // id del panel destino (con o sin '#')
    title?: string;
}

const { color = "blue", target = "", title = "" } = Astro.props;
---

<!--
  Componente “dot” selector de panel.
  - data-color: clave en la paleta
  - data-target: id del panel destino (ej: "panel-1" o "#panel-1")
  - Accesible con title y aria-label
-->
<color-dot
    data-color={color}
    data-target={target}
    title={title || color}
    aria-label={title || color}
    class="shadow-2xl"
    style={`--dot-color:${palette[color]}; --dot-ring:${palette[color]}66`}
>
    <button
        class="w-3.5 h-3.5 rounded-full shadow-2xl hover:scale-125 transition-transform cursor-pointer"
        style={`background:${palette[color]}`}
        type="button"></button>
</color-dot>

<script>
    /**
     * Gestor de transiciones entre paneles con efecto "wipe".
     * Supone:
     *  - Panel activo: .panel.is-active
     *  - Overlay de transición opcional dentro del panel: .wipe
     *  - CSS define @keyframes para .wipe cuando el panel tiene .reveal
     *
     * Si cambias nombres de clases o estructura de paneles, ajusta los selectores aquí.
     */

    let txCounter = 0;

    /** @typedef {{ id:number, next:HTMLElement, curr:HTMLElement|null, wipe:HTMLElement|null, toHide:HTMLElement[], prevBg:string, onEnd:(ev:AnimationEvent)=>void }} RunningState */

    /** Transición en curso (o null si no hay). */
    /** @type {RunningState|null} */
    let running = null;

    /** Normaliza un selector de id. Acepta "panel-1" o "#panel-1". */
    const normId = (s) => (s ? (s[0] === "#" ? s : "#" + s) : "");

    /** Quita restos de `.reveal` por animaciones interrumpidas. */
    const cleanupReveal = () => {
        document
            .querySelectorAll(".panel.reveal")
            .forEach((p) => p.classList.remove("reveal"));
    };

    /**
     * Oculta/muestra todos los hijos del panel salvo el overlay `.wipe`.
     * Útil si quieres que el contenido aparezca sólo al terminar el wipe.
     * Devuelve la lista de nodos afectados para poder revertir rápido.
     */
    const setChildrenVisibility = (panel, hidden) => {
        /** @type {HTMLElement[]} */
        const kids = Array.from(panel.children).filter(
            (el) => !el.classList.contains("wipe"),
        );
        kids.forEach((el) => (el.style.visibility = hidden ? "hidden" : ""));
        return kids;
    };

    /** Marca el dot activo según el panel visible. */
    const markActiveDot = (panel) => {
        document
            .querySelectorAll('color-dot[data-active="true"]')
            .forEach((el) => el.removeAttribute("data-active"));
        const dot = document.querySelector(
            `color-dot[data-target="#${panel.id}"]`,
        );
        if (dot) dot.setAttribute("data-active", "true");
    };

    /**
     * Cancela una transición en curso y deja todo coherente.
     * Úsalo cuando el usuario hace clic de nuevo a mitad de animación.
     */
    const cancelRunning = () => {
        if (!running) return;
        const { next, curr, wipe, onEnd, toHide, prevBg } = running;

        if (wipe && onEnd) wipe.removeEventListener("animationend", onEnd);

        next.classList.remove("reveal", "is-active");
        next.style.zIndex = "0";
        next.style.background = prevBg || "";
        toHide.forEach((el) => (el.style.visibility = ""));

        if (curr) {
            curr.classList.add("is-active");
            curr.style.zIndex = "1";
        }

        running = null;
    };

    /**
     * Cambia al panel `next`. Si existe `.wipe` dentro de `next`, ejecuta animación.
     * Si no, hace el cambio instantáneo.
     */
    const goToPanel = (next, curr) => {
        if (next === curr) return;

        const prevBg = next.style.background;
        const nextColor = getComputedStyle(next).backgroundColor;

        // Preparar destino: visible, al frente, contenido oculto y fondo transparente
        const toHide = setChildrenVisibility(next, true);
        next.style.background = "transparent";
        if (curr) curr.style.zIndex = "0";
        next.style.zIndex = "2";
        next.classList.add("is-active");

        const id = ++txCounter;
        /** @type {HTMLElement|null} */
        const wipe = next.querySelector(".wipe");

        const finish = () => {
            // Ignora eventos de una transición vieja si hubo clices rápidos
            if (!running || running.id !== id) return;

            next.style.zIndex = "1";
            next.classList.remove("reveal");
            if (curr) curr.classList.remove("is-active");

            // Restaura fondo y muestra contenido del destino
            next.style.background = prevBg || nextColor;
            setChildrenVisibility(next, false);

            // Actualiza indicador de dot activo
            markActiveDot(next);

            running = null;
        };

        if (wipe) {
            // Reinicia la animación CSS para poder dispararla de nuevo
            wipe.style.animation = "none";
            wipe.style.setProperty("--wipe-color", nextColor);

            // Disparo en frame siguiente para que el navegador procese el "none"
            requestAnimationFrame(() => {
                if (running && running.id !== id) return;
                next.classList.add("reveal");
                wipe.style.animation = ""; // reaplica @keyframes definidos en CSS
                wipe.addEventListener("animationend", finish, { once: true });
            });

            running = { id, next, curr, wipe, toHide, prevBg, onEnd: finish };
        } else {
            // Sin overlay: cambio inmediato
            next.style.zIndex = "1";
            if (curr) curr.classList.remove("is-active");
            next.style.background = prevBg || nextColor;
            setChildrenVisibility(next, false);
            markActiveDot(next);
            running = null;
        }
    };

    /**
     * Web Component <color-dot>
     * - Lee `data-target` y navega al panel correspondiente al hacer clic.
     * - No acopla estilos ni estructura de paneles, sólo usa clases/ids.
     */
    class ColorDotEl extends HTMLElement {
        connectedCallback() {
            const btn = this.querySelector("button");
            if (!btn) return;

            btn.addEventListener("click", () => {
                const sel = normId(this.dataset.target);
                if (!sel) return;

                cleanupReveal(); // limpia estados residuales
                cancelRunning(); // corta animación previa si la hay

                /** @type {HTMLElement|null} */
                const next = document.querySelector(sel);
                /** @type {HTMLElement|null} */
                const curr = document.querySelector(".panel.is-active");
                if (!next) return;

                goToPanel(next, curr);
            });
        }
    }

    // Registro del custom element una única vez
    if (!customElements.get("color-dot")) {
        customElements.define("color-dot", ColorDotEl);

        // Al iniciar, marca el dot del panel activo o el primero disponible
        requestAnimationFrame(() => {
            const active = document.querySelector(".panel.is-active");
            if (active instanceof HTMLElement) {
                markActiveDot(active);
            } else {
                const first = document.querySelector("color-dot[data-target]");
                if (first) first.setAttribute("data-active", "true");
            }
        });
    }
</script>
