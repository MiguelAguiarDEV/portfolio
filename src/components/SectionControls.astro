---
interface Props {
    sectionId: string;
    bgColor?: string;
    title?: string;
    showXDisplacement?: boolean;
    showWipeAngle?: boolean;
    showStaticXOffset?: boolean;
    defaultX?: number;
    defaultWipe?: number;
    defaultStatic?: number;
}

const {
    sectionId,
    bgColor = "#6b7280",
    title = "Controls",
    showXDisplacement = true,
    showWipeAngle = true,
    showStaticXOffset = true,
    defaultX = 0,
    defaultWipe = 40,
    defaultStatic = 41,
} = Astro.props;

// Precompute unique element IDs for sliders and their value labels
const xId = `xDisplacementInput-${sectionId}`;
const xLabelId = `${xId}Label`;
const wipeId = `wipeAngleInput-${sectionId}`;
const wipeLabelId = `${wipeId}Label`;
const staticId = `staticXOffsetInput-${sectionId}`;
const staticLabelId = `${staticId}Label`;
const resetBtnId = `reset-${sectionId}`;
// Fallback defaults aligned with Section's CSS vars; runtime will refine from actual DOM values
const serverDefaults = { x: defaultX, wipe: defaultWipe, stat: defaultStatic };
---

<form
    id={`slider-form-${sectionId}`}
    class="pointer-events-auto w-[min(92vw,22rem)] md:w-[22rem] bg-white/80 text-zinc-900 dark:bg-zinc-900/70 dark:text-zinc-100 backdrop-blur-xl border border-white/20 dark:border-zinc-700/60 rounded-2xl shadow-xl p-4 md:p-5 flex flex-col gap-4"
>
    <div class="flex items-center justify-between">
        <div class="text-sm font-semibold tracking-wide">{title}</div>
        <div class="flex items-center gap-2 text-[10px]">
            <span
                class="px-2 py-0.5 rounded-full bg-zinc-100 text-zinc-700 dark:bg-zinc-800 dark:text-zinc-200 border border-zinc-200/50 dark:border-zinc-700/60"
                >ID {sectionId}</span
            >
            <span
                class="px-2 py-0.5 rounded-full bg-zinc-100 text-zinc-700 dark:bg-zinc-800 dark:text-zinc-200 border border-zinc-200/50 dark:border-zinc-700/60"
                >BG {bgColor}</span
            >
            <button
                id={resetBtnId}
                type="button"
                class="ml-2 inline-flex items-center gap-1 px-2 py-1 rounded-md border border-zinc-300/70 dark:border-zinc-700/70 bg-white/70 dark:bg-zinc-800/70 text-zinc-700 dark:text-zinc-200 hover:bg-white/90 dark:hover:bg-zinc-800/90 transition text-[10px]"
                >Reset</button
            >
        </div>
    </div>
    <hr class="border-zinc-200/40 dark:border-zinc-700/50" />

    <div class="flex flex-col gap-4">
        <!-- X-Displacement -->
        <div
            class="flex flex-col gap-2"
            class:list={{ hidden: !showXDisplacement }}
        >
            <div class="flex items-center justify-between text-xs">
                <label
                    for={xId}
                    class="font-medium text-zinc-600 dark:text-zinc-300"
                    >X-Displacement</label
                >
                <span
                    id={xLabelId}
                    class="ml-2 px-2 py-0.5 rounded bg-zinc-200 dark:bg-zinc-700 text-zinc-800 dark:text-zinc-100 font-mono tabular-nums"
                    >0</span
                >
            </div>
            <input
                id={xId}
                type="range"
                min="0"
                max="100"
                value="0"
                class="ui-range w-full accent-indigo-600 focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500/60 focus-visible:ring-offset-0"
            />
        </div>

        <!-- Wipe Angle -->
        <div
            class="flex flex-col gap-2"
            class:list={{ hidden: !showWipeAngle }}
        >
            <div class="flex items-center justify-between text-xs">
                <label
                    for={wipeId}
                    class="font-medium text-zinc-600 dark:text-zinc-300"
                    >Wipe Angle</label
                >
                <span
                    id={wipeLabelId}
                    class="ml-2 px-2 py-0.5 rounded bg-zinc-200 dark:bg-zinc-700 text-zinc-800 dark:text-zinc-100 font-mono tabular-nums"
                    >40</span
                >
            </div>
            <input
                id={wipeId}
                type="range"
                min="0"
                max="100"
                value="40"
                class="ui-range w-full accent-indigo-600 focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500/60 focus-visible:ring-offset-0"
            />
        </div>

        <!-- Static X-Offset -->
        <div
            class="flex flex-col gap-2"
            class:list={{ hidden: !showStaticXOffset }}
        >
            <div class="flex items-center justify-between text-xs">
                <label
                    for={staticId}
                    class="font-medium text-zinc-600 dark:text-zinc-300"
                    >Static X-Offset</label
                >
                <span
                    id={staticLabelId}
                    class="ml-2 px-2 py-0.5 rounded bg-zinc-200 dark:bg-zinc-700 text-zinc-800 dark:text-zinc-100 font-mono tabular-nums"
                    >41</span
                >
            </div>
            <input
                id={staticId}
                type="range"
                min="-100"
                max="100"
                value="41"
                class="ui-range w-full accent-indigo-600 focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500/60 focus-visible:ring-offset-0"
            />
        </div>
    </div>
</form>

<script
    define:vars={{
        sectionId,
        xId,
        xLabelId,
        wipeId,
        wipeLabelId,
        staticId,
        staticLabelId,
        resetBtnId,
        serverDefaults,
    }}
>
    // @ts-nocheck
    console.log("[SectionControls] init", { sectionId });
    const sliderForm = document.getElementById(`slider-form-${sectionId}`);
    const formContainer = document.getElementById("form-container");
    if (formContainer && sliderForm) {
        formContainer.appendChild(sliderForm);
        console.log("[SectionControls] form appended");
    } else {
        console.warn("[SectionControls] missing container or form", {
            hasFormContainer: !!formContainer,
            hasSliderForm: !!sliderForm,
        });
    }

    function waitForSection(id, timeout = 3000) {
        return new Promise((resolve, reject) => {
            const found = document.getElementById(id);
            if (found) return resolve(found);
            const start = Date.now();
            const timer = setInterval(() => {
                const el = document.getElementById(id);
                if (el) {
                    clearInterval(timer);
                    resolve(el);
                } else if (Date.now() - start > timeout) {
                    clearInterval(timer);
                    reject(new Error("timeout"));
                }
            }, 50);
        });
    }

    function wireSlider(sectionElement, inputId, labelId, cssVar) {
        const slider = document.getElementById(inputId);
        const valueLabel = document.getElementById(labelId);
        if (!slider || !valueLabel || !sectionElement) {
            console.warn("[SectionControls] wireSlider missing", {
                inputId,
                labelId,
                hasSlider: !!slider,
                hasValueLabel: !!valueLabel,
                hasSection: !!sectionElement,
            });
            return;
        }
        const update = () => {
            const minNum = Number(slider.min ?? 0);
            const maxNum = Number(slider.max ?? 100);
            const valNum = Number(slider.value ?? 0);
            const pct = ((valNum - minNum) / (maxNum - minNum)) * 100;
            valueLabel.textContent = String(valNum);
            slider.style.backgroundSize = `${pct}% 100%`;
            sectionElement.style.setProperty(cssVar, `${valNum}%`);
            console.log("[SectionControls] set", { inputId, cssVar, valNum });
        };
        slider.addEventListener("input", update);
        update();
    }

    async function init() {
        let sectionElement = document.getElementById(sectionId);
        if (!sectionElement) {
            try {
                sectionElement = await waitForSection(sectionId, 3000);
            } catch (e) {
                console.warn("[SectionControls] no section found", sectionId);
                return;
            }
        }
        wireSlider(sectionElement, xId, xLabelId, "--x-displacement");
        wireSlider(sectionElement, wipeId, wipeLabelId, "--wipe-angle");
        wireSlider(
            sectionElement,
            staticId,
            staticLabelId,
            "--static-x-offset",
        );

        const resetBtn = document.getElementById(resetBtnId);
        const xEl = document.getElementById(xId);
        const wipeEl = document.getElementById(wipeId);
        const statEl = document.getElementById(staticId);
        const runtimeDefaults = {
            x: xEl ? Number(xEl.value) : serverDefaults.x,
            wipe: wipeEl ? Number(wipeEl.value) : serverDefaults.wipe,
            stat: statEl ? Number(statEl.value) : serverDefaults.stat,
        };
        if (resetBtn) {
            resetBtn.addEventListener("click", () => {
                console.log("[SectionControls] reset clicked", {
                    sectionId,
                    runtimeDefaults,
                });
                if (xEl) {
                    xEl.value = String(runtimeDefaults.x);
                    xEl.dispatchEvent(new Event("input", { bubbles: true }));
                }
                if (wipeEl) {
                    wipeEl.value = String(runtimeDefaults.wipe);
                    wipeEl.dispatchEvent(new Event("input", { bubbles: true }));
                }
                if (statEl) {
                    statEl.value = String(runtimeDefaults.stat);
                    statEl.dispatchEvent(new Event("input", { bubbles: true }));
                }
                console.log("[SectionControls] reset applied", runtimeDefaults);
            });
        }
    }

    if (document.readyState === "loading") {
        window.addEventListener("DOMContentLoaded", init, { once: true });
    } else {
        requestAnimationFrame(init);
    }
</script>
